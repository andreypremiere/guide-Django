# Инструкция по Django
----

## Основные команды
----

__Создание проекта__

```
django-admin startproject nameproject
```

__Запуск тестового сервера__

```
python manage.py runserver
```

Запуск на определенном порту

```
python manage.py runserver 4000

```

__Создание приложения__

```
python manage.py startapp nameapp
```

__Миграции__

Для создания и обновления таблиц определенных структур  в моделях.

Создать файл миграций:

```
python manage.py makemigrations
```

Выполнить миграции:

```
python manage.py migrate
```

Посмотреть sql запрос, который будет выполнен для создания таблицы:

```
python manage.py sqlmigrate listuneversity(название модели) 0001(порядковый номер миграции)
```

# Jinja 2
----

```
{{ name }} # подстановка переменных происходит в двух фигурных скобках

{% anything %} # спецификатор шаблона

{# #} # блок комментариев

'# ##' # строковый комментарий
```

можно совершать операции языка python:

```
{{ number*2 }}
{{ somestring.upper() }}
```

*Можно передавать экземпляры класса, словари и многое другое*

Чтобы данные не преобразовывались, нужно их поместить в следующий блок:

```
{% raw %} ... {% endraw %}
```

Чтобы в переменной link экранировались специальные символы, а не выполнялись, в шаблоне нужно указать специальный тег е:

```
{{ link | e }}
```

Выражение for:

```
{%- for i in something -%} # с помощью минусов около процентов можно убирать и добавлять переносы строк
    <тело цикла>
{%- endfor -%}
```

Выражение if:

```
{% if <условие> %}
    <тело при истинности условия>
{% elif <условие> %}
    <действие>
{% else %}
    <во всех осталььных случаях>
{% endif %}```

Фильтры:

```
cars = [{'model': 'audi', 'price': 30000}, {'model': 'bmw', 'price': 45000}]

render(cs=cars)

{{ cs | sum(attribute='price') }}
```

Полный список фильтров: https://jinja.palletsprojects.com/en/2.11.x/templates/

Макроопределения позволяют сделать какой-либо шаблон (что-то вроде функций), который потом можно вызывать.

Конструкция include:

```
{% include 'путь к файлу' %}
{% include 'путь к файлу' ignore missing %} # проигнорирует файлы, которые не смогли подключиться
{% include ['путь к файлу', 'еще один путь к файлу'] %}
```

Конструкция import:

```
{% import 'путь к файлу' as 'как будем обращаться' %}
```

Наследование:

```
{% extends 'путь к файлу' %}
```

Также можно повторно вызывать блоки:

```
{% block title %} Some information {% endblock %}

{{ self.title() }}
```

Метод super():

Передает информацию из базового блока в тот блок, в котором к нему обращаются

```
{{ super() }}
```


# Теория
----

Структура папки приложения:

* папка migrations - для хранения миграций баз данных приложений;
* admin.py - для связи приложения с админ-панелью;
* apps.py - для настройки текущего приложения;
* models.py - для хранения ORM моделей (представления моделей из базы данных);
* tests.pt - модуль с тестирующими процедурами;
* views.py - для хранения представлений текущего приложения.

После создания приложения нужно его зарегестрировать в пакете конфигураций settings.py в INSTALLED_APPS.

Типы передаваем данных в url:

```
path('cats/<int:value>/', function)
```

* str - любая не пустая строка, исключая символ '/';
* int - любое положительное целое число, включая 0;
* slug - слаг, то есть, латиница ASCII таблицы, символы дефиса и подчеркивания;
* unid - цифры, малые латинские символеы ASCII, дефис;
* path - любая не пустая строка, включая символ '/'.

Функция представления должна принимать это значение в аргументах(function(request, value))

*request используется для обработки GET запросов (аналагичным способом можно работать и с POST запросом)*

Получить данные из get запроса можно обратившись:

```
request.GET # получим словарь
```

__Перенос на страницу__

Функция redirect из django.shortcuts перенапрявляет на какую-либо страницу:

```
return redirect('home') #!лучше передавать url адрес по имени!
```

В urls.py:

```
path('', index, name='home')
```

__ORM__

Объектно-реляционное отображение
Благодаря django orm приложение может работать с такими базами как: SQLite, MySQL, PostgreSQL, Oracle, не прибегая к изменениям моделей.

__Настройка базы данных__

Находится в файле settings.py в пакете конфигураций.

Прежде чем приступить к настройке подключения, убедитесь, что в вашей системе настроен MySQL. Убедитесь, что у вас есть учетная запись и созданы базы данных, к которым вы хотите подключиться.

Более того, вам также потребуется клиент MySQL для взаимодействия с базами данных с помощью Python.

```
pip install mysqlclient
```

Также если не установлен пакет Pillow, его тоже потребуется установить.

```
python3 -m pip install --upgrade Pillow
```

Параметры в setting.py

```
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql', 
        'NAME': 'databaseName', # имя базы данных
        'USER': 'databaseUser', # имя пользователя
        'PASSWORD': 'databasePassword', # пароль
        'HOST': 'localhost',
        'PORT': 'portNumber', # больше дополнительный параметр
    }
}
```

__Модели данных__

Чтобы в базе данных появилась таблица с определенной структурой, необходимо объявить класс в файле models.py пакета приложения с необходимыми полями и выполнить миграцию.

Последовательность будет такая же, как в модели.

Пример:

```
class Man(models.Model): # наследуем класс Model
    title = models.CharField(max_length=256)
    content = models.TextField(blank=True)
    photo = models.ImageField(upload_to='photos/%Y/%n/%d') # в какой каталог будем загружать изображения с шаблоном
    time_create = models.DateTimeField(auto_now_add=True)
    is_published = models.BooleanField(default=False)
```

*id автоматически прописано в Model*

Для загрузки различных файлов (в том числе и медиа) и корректной работы необходимо настроить MEDIA_ROOT и MEDIA_URL (подробнее смотреть в документации)

Краткая инструкция:

В пакете конфигураций settings.py добавляем описание этих констант:

```
MEDIA_ROOT = os.path.join(BASE_DIR, 'media') # ссылается на папку media в текущем рабочем каталоге
MEDIA_URL = '/media/' # добавляет к url графическим файлам такой префикс
```

Для передачи раннее загруженных медиа файлов нужно сэмулировать работу реального сервера.

Для этого пропишем в urls пакета конфигураций:

```
if settings.DEBUG:
    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)
```

__CRUD__

Основы работы с моделями. Create, read, update, delete.

Для работы с orm django:

```
python manage.py shell #войти
```

Импортируем модель, с которой хотм работать:

```
from manageevents.models import ListUniversity
```

Создать новую запись в таблице:

```
ListUniversity(title='ИКИТ')
```

Присвоем переменной n1 результат последних действий:

```
n1 = _
```

Чтобы поместить созданный объект в самой базе из django orm:

```
n1.save()
```

Еще несколько команд:

```
n1.id # узнать id, также можно и с остальными полями
n1.pk # узнать id?
connection.queries # посмотреть список выполненных sql запросов
exit() # выход из оболочки
```

или воспользоваться методом objects:

```
n2 = ListUniversity.objects.create(title='ГИ') # запись сразу попадает в базу данных (можно без создания переменной)
```

Просмотреть записи можно:

```
ListUniversity.objects.all() # выведет все записи в виде списка
ListUniversity.objects.filter(title='ИКИТ') # в скобках указываем параметры фильтра
ListUniversity.objects.exclude(title='ИКИТ') # исключая все записи с такими параметрами
```

Более подробно здесь: https://proproprogs.ru/django

__Статические файлы. Фильтры шаблонов__

В режиме отладки django ищет статические файлы во всех папках static каждого приложения, в режиме эксплуатации собирает их в одну папку static.

При подготовке проекта к эксплуатации необходимо выполнить следующую команду:

```python manage.py collectstatic```

Перемещает все в одну папку static.

Поэтому важно определить в settings.py следующие переменные:

* STATIC_URL - префикс url-адреса для статических файлов.
* STATIC_ROOT - путь к общей статической папке, используемой реальным веб-сервером.
* STATICFILES_DIRS - список дополнительных (нестандартных) путей к статическим файлам, используемых для сбора и для режима отладки.

Подключение стилей:

Прописываем перед DOCTYPE загрузку статических файлов:

```{% load static %}```

В head пишем ссылку к файлу относительно каталога static:

```
<link type="text/css" href="{% static 'manageevents/css/style.css'" rel="stylesheet">
```
